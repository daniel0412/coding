## Status
| Icon                     | Meaning           |
| :---:                    | :-----            |
| :v:                      | passed            |
| :lock: | locked problem    |
| :warning:                | truely hard       |
| :eyes:                   | worth second look |

## Solved problems not in Google list
 | Problems                    | Difficulty | Techniques                  | Status            |
 | :-------------------------  | :---:      | ----:                       | :---:             |
 | Binary Tree Right Side View | Medium     | level traversal (dfs/queue) | :v:               |
 | Nested List Weight Sum      | Easy       | recursion                   | :v: :lock:        |
 | Nested List Weight Sum II   | Medium     | recursion with states       | :v: :eyes: :lock: |

## Google(90)
 | Problems                                               | Difficulty | Techniques                                             | Status            |
 | :-------------------------                             | :---:      | :----                                                  | :---:             |
 | Reverse Pair                                           | Hard       | divide and conqure(slow)                               | :v: :eyes:        |
 | Median of Two Sorted Arrays                            | Hard       | binary search                                          | :v:        :eyes: |
 | Find Median from Data Stream                           | Hard       | heap                                                   | :v:               |
 | Sort Transformed Array                                 | Medium     | quadratic function, dist from optimal                  | :eyes: :v:        |
 | SlidingWindowMedian                                    | Hard       | multiset                                               | :v:               |
 | Wildcard Matching                                      | Hard       | two pointer                                            | :v:               |
 | Regular Expression Matching                            | Hard       |                                                        |                   |
 | Expression Add Operators                               | Hard       |                                                        |                   |
 | Populating Next Right Pointers in Each Node II         | Hard       | iteration                                              | :v: :eyes:        |
 | Populating Next Right Pointers in Each Node            | Medium     | iteration                                              | :v:               |
 | Insert Interval                                        | Hard       | corner cases                                           | :v:               |
 | Merge Intervals                                        | Medium     |                                                        | :v:               |
 | Word Squares                                           | Hard       | dfs/trie                                               | :warning: :lock:  |
 | Valid Word Square                                      | Easy       | brute force                                            | :lock:            |
 | Trapping Rain Water                                    | Hard       |                                                        |                   |
 | LRU Cache                                              | Hard       | double linked list/map                                 | :v: :eyes:        |
 | LFU Cache                                              | Hard       | double linked list/map                                 | :v: :eyes:        |
 | Letter Combinations of a Phone Number                  | Medium     |                                                        |                   |
 | Longest Absolute File Path                             | Medium     | stack/two pointer                                      | :v:               |
 | Walls and Gates                                        | Medium     | dfs/bfs/reverse engineer                               | :v: :eyes: :lock: |
 | The Maze                                               | Medium     | dfs                                                    | :eyes: :lock:     |
 | The Maze II                                            | Medium     | dfs(mark/recover visited)                              | :eyes: :lock:     |
 | The Maze III                                           | Hard       |                                                        |                   |
 | 01 Matrix                                              | Medium     | dfs(TLE)/bfs/two pass idea(fastest)                    | :eyes: :v:        |
 | Lonely Pixel I                                         | Medium     | 2-D vector                                             | :lock:            |
 | Lonely Pixel II                                        | Medium     |                                                        | :eyes: :lock:     |
 | Valid Parentheses                                      | Easy       |                                                        |                   |
 | Moving Average From Data Stream                        | Easy       | queue                                                  | :lock:            |
 | Generate Parentheses                                   | Medium     |                                                        |                   |
 | Pow(x, n)                                              | Medium     |                                                        |                   |
 | Spiral Matrix                                          | Medium     |                                                        |                   |
 | License Key Formatting                                 | Medium     | string operation                                       | :v:               |
 | Plus One                                               | Easy       |                                                        |                   |
 | Word Break II                                          | Hard       | dp/back tracking/prunning                              | :v: :eyes:        |
 | Word Break                                             | Medium     | dp                                                     | :v: :eyes:        |
 | Min Stack                                              | Easy       |                                                        |                   |
 | Read N Characters Given Read4 II â€“ Call multiple times | Hard       |                                                        |                   |
 | Repeated Substring Pattern                             | Easy       |                                                        | :eyes: :v:        |
 | Heaters                                                | Easy       | upper/lower bound                                      | :eyes: :v:        |
 | Find Peak Element                                      | Medium     |                                                        |                   |
 | Fraction to Recurring Decimal                          | Medium     | hashmap/sstream/overflow                               | :v:               |
 | Number of Islands                                      | Medium     |                                                        |                   |
 | Implement Trie (Prefix Tree)                           | Medium     |                                                        |                   |
 | Word Search II                                         | Hard       |                                                        |                   |
 | The Skyline Problem                                    | Hard       |                                                        |                   |
 | Basic Calculator                                       | Hard       |                                                        |                   |
 | Summary Ranges                                         | Medium     | stringstream/array/size_t                              | :v:               |
 | Missing Ranges                                         | Medium     | same as above                                          | :v:               |
 | Power of Two                                           | Easy       |                                                        |                   |
 | Sliding Window Maximum                                 | Hard       |                                                        |                   |
 | Diagonal Traversal                                     | Medium     | own impl so slow: how to deal with bounary univasally  | :v:               |
 | Strobogrammatic Number                                 | Easy       | hashmap                                                | :v: :lock:        |
 | Strobogrammatic Number II                              | Medium     | backtracking                                           | :v: :lock:        |
 | Strobogrammatic Number III                             | Hard       | combination/backtracking                               | :v: :lock: :eyes: |
 | Group Shifted Strings                                  | Easy       |                                                        |                   |
 | Meeting Rooms II                                       | Medium     | sort/heap                                              | :v: :eyes: :lock: |
 | Meeting Rooms                                          | Easy       |                                                        | :v: :lock:        |
 | 3Sum Smaller                                           | Medium     |                                                        |                   |
 | Alien Dictionary                                       | Hard       |                                                        |                   |
 | Search a 2D Matrix                                     | Medium     | binary search, location conversion                     | :v:               |
 | Search a 2D Matrix II                                  | Medium     | find correct starting location                         | :v: :eyes:        |
 | Kth Largest Element in an Array                        | Medium     | quick select/heap                                      | :v: :eyes:        |
 | Kth Smallest Element in a BST                          | Medium     | iterative/recursive, make sure return type             | :eyes: :v:        |
 | Kth Smallest Element in a sorted matrix                | Medium     | 1. heap 2. binary search for the answer + cnt          | :eyes: :v:        |
 | Find K Closest Elements                                | Medium     |                                                        | :v:               |
 | Find K Pairs with Smallest Sum                         | Medium     | heap idea                                              | :eyes: :v:        |
 | Find Kth Smallest Pair Distance                        | Hard       | find dist boundary, and then binary search             | :eyes: :v:        |
 | Encode and Decode Strings                              | Medium     |                                                        |                   |
 | H-Index                                                | Medium     |                                                        |                   |
 | Logger Rater Limitter                                  | Easy       | map                                                    | :v:               |
 | Paint Fence                                            | Easy       |                                                        |                   |
 | Perfect Squares                                        | Medium     |                                                        |                   |
 | Wiggle Sort                                            | Medium     |                                                        |                   |
 | Peeking Iterator                                       | Medium     | subtyping                                              | :v: :eyes:        |
 | Flatten Nested List Iterator                           | Medium     | use stack to track begin/end, hasNext promote pointers | :eyes: :v:        |
 | Flatten 2D Vector                                      | Medium     | track row, col index                                   | :v:               |
 | Zigzag Iterator                                        | Medium     |                                                        |                   |
 | Binary Search Tree Iterator                            | Medium     | inorder iterative impl                                 | :v:               |
 | Unique Word Abbreviation                               | Easy       | pass                                                   | :lock:            |
 | Valid Word Abbreviation                                | Easy       |                                                        | :lock:            |
 | Generalized Abbreviation                               | Medium     | dfs                                                    | :lock:            |
 | Game of Life                                           | Medium     | track state, note state changes cell value             | :eyes: :v:        |
 | Flip Game                                              | Easy       |                                                        |                   |
 | Flip Game II                                           | Medium     |                                                        |                   |
 | Max Consecutive Ones                                   | Easy       |                                                        | :v:               |
 | Max Consecutive Ones  II                               | Medium     | idea                                                   | :eyes: :v:        |
 | Longest Increasing Path in a Matrix                    | Hard       | dfs + memorization to prun                             | :eyes: :v:        |
 | Longest Increasing Subsequence                         | Medium     | construct array, then binary search to replace         | :eyes: :v:        |
 | Number of Longest Increasing Subsequence               | Medium     |                                                        | :eyes: :v:        |
 | Smallest Rectangle Enclosing Black Pixels              | Hard       | 1. brute force  2. four directions binary search idea  | :eyes: :lock:     |
 | Max Sum of Rectangle No Greater Thank K                | Hard       | idea: max sum of sub rectangle + lower bound  of diff  | :eyes: :v:        |
 | Number of Islands II                                   | Hard       |                                                        |                   |
 | Range Sum Query 2D â€“ Mutable                           | Hard       |                                                        |                   |
 | Minimum Height Trees                                   | Medium     |                                                        |                   |
 | Burst Balloons                                         | Hard       |                                                        |                   |
 | Super Ugly Number                                      | Medium     |                                                        |                   |
 | Binary Tree Vertical Order Traversal                   | Medium     | tree traversal                                         | :lock:            |
 | Count of Smaller Numbers After Self                    | Hard       | binary search/lower bound                              | :v: :eyes:        |
 | Remove Duplicate Letters                               | Hard       | map/stack                                              | :v: :eyes:        |
 | Best Meeting Point                                     | Medium     | consider one dimensional case                          | :eyes: :v:        |
 | Shortest Distance from All Buildings                   | Hard       | bfs, shortest dist + accessible from all buildings     | :eyes: :v:        |
 | Maximum Product of Word Lengths                        | Medium     |                                                        |                   |
 | Friend Cycle                                           | Medium     | union find (var to track count, when union reduce one) | :eyes: :v:        |
 | Number of Connected Components in an Undirected Graph  | Medium     | union find/dfs(vector with diff vals to track state    | :eyes: :lock:     |
 | Wiggle Sort II                                         | Medium     |                                                        |                   |
 | Power of Three                                         | Easy       |                                                        |                   |
 | Count of Range Sum                                     | Hard       | multiset/bounds                                        | :v: :eyes:        |
 | Patching Array                                         | Hard       | greedily expand [0, sum) range                         | :eyes: :v:        |
 | Verify Preorder Serialization of a Binary Tree         | Medium     |                                                        |                   |
 | Reconstruct Itinerary                                  | Medium     |                                                        |                   |
 | Remove K Digits                                        | Medium     | idea                                                   | :eyes: :v:        |
 | Create Maximum Number                                  | Hard       | max num from one array/merge/try  all combinations     | :eyes: :eyes: :v: |
 | Design Phone Directory                                 | Medium     | keep track of recycled and used                        | :v:               |

## Facebook(79)
 | Problems                                               | Difficulty | Related Problems                                            | Status              |
 | :-------------------------                             | :---:      | :----                                                       | :---:               |
 | Move Zeroes                                            | Easy       | array/swap                                                  | :v:                 |
 | Split Array into Consecutive Sequence                  | Medium     | array sorted, greedy idea                                   | :eyes: :v:          |
 | Split Array With Equal Sums                            | Medium     | cache sum + split strategy                                  | :eyes: :lock:       |
 | Split Array Largest Sum                                | Hard       | find range, then binary search /dp                          | :eyes:  :v:         |
 | Rearrange String K Distance Apart                      | Hard       | hash/heap/rearrange task w/o reorder                        | :lock: :eyes:       |
 | Task Scheduler                                         | Medium     | find formular + heap solution                               | :eyes: :v:          |
 | Continuous Subarray Sum                                | Medium     | hash map/(a-c)%b==0/cornercase                              | :v: :eyes:          |
 | Maximum Subarray                                       | Easy       | dp/think about divide & conqure                             | :v:                 |
 | Maximum Sum of 3 Non-overlapping Subarrays             | Hard       | presum, fix middle subarray, dp to cache left/right max     | :eyes: :v:          |
 | Minimum Size Subarray Sum                              | Medium     | two pointer find range, then reduce range, analyze why O(n) | :eyes: :v:          |
 | Maximum Size Subarray Sum Equals k                     | Medium     | hash map/idea                                               | :v: :eyes:          |
 | Subarray Sum Equals k                                  | Medium     | hash map/idea                                               | :v: :eyes:          |
 | Subarray Prod Less Than k                              | Medium     | idea                                                        | :eyes: :v:          |
 | Divide Two Integers                                    | Medium     | hash map/prefix sum                                         | :v: :eyes:          |
 | Roman to Integer                                       | Easy       | add then minus two if voliate                               | :v: :eyes:          |
 | Integer to Roman                                       | Medium     | find separating points, then all adding                     | :v: :eyes:          |
 | Integer to English Words                               | Hard       | list all special cases + convert hundreds                   | :v: :eyes:          |
 | Multiply Strings                                       | Medium     | string addition/accumulate+reverse/quicker sol              | :v: :eyes:          |
 | Reverse String                                         | Easy       |                                                             | :v:                 |
 | Reverse StringII                                       | Easy       |                                                             | :v:                 |
 | Magical String                                         | Medium     | think about how to generate it                              | :eyes: :v:          |
 | Add Binary                                             | Easy       | bit by bit                                                  | :v:                 |
 | Letter Combinations of a Phone Number                  | Medium     | dfs                                                         | :v:                 |
 | Read N Characters Given Read4                          | Easy       | so concise                                                  | :lock: :eyes:       |
 | Read N Characters Given Read4 II â€“ Call multiple times | Hard       | buffer/read-write pos tracker                               | :lock: :eyes:       |
 | Remove Duplicates from Sorted Array                    | Easy       | two pointer                                                 | :v:                 |
 | Remove Duplicates from Sorted Array II                 | Medium     | two pointer + condition                                     | :v:                 |
 | Merge Sorted Array                                     | Easy       | two pointer                                                 | :v:                 |
 | Merge k Sorted Lists                                   | Hard       | min heap                                                    | :v:                 |
 | Product of Array Except Self                           | Medium     | left->right, then right->left                               | :v:                 |
 | Reverse Nodes in k-Group                               | Hard       |                                                             |                     |
 | Implement strStr()                                     | Easy       |                                                             |                     |
 | Count and Say                                          | Easy       | iterative/recursive/deduction                               | :v:                 |
 | Pow(x, n)                                              | Medium     |                                                             |                     |
 | Sqrt(x)                                                | Medium     |                                                             |                     |
 | Merge Intervals                                        | Medium     | customized sorting + max(end1, end2) when merge             | :v:                 |
 | Insert Interval                                        | Hard       | think about it twice                                        | :v: :eyes:          |
 | Encode/Decode Tiny Url                                 | Medium     | rand()/unordered_map                                        | :v: :eyes:          |
 | Simplify Path                                          | Medium     | last char not being '/' case                                | :v:                 |
 | Wildcard Matching                                      | Hard       | greedy two pointer: mark * matchign start pos               | :v: :eyes:          |
 | Regular Expression Matching                            | Hard       | hard&slow recursion/fast dp!!!                              | :v: :eyes:          |
 | Text Justification                                     | Hard       | just deal with string corner case                           | :v:                 |
 | Expression Add Operators                               | Hard       | tricy dfs: get first val, then (op, val) pair               | :v: :eyes:          |
 | Increasing Subsequence                                 | Medium     | dfs/set to deduplicate                                      | :v:          :eyes: |
 | Word Ladder                                            | Medium     | (double) bfs                                                | :eyes: :v:          |
 | Word Ladder II                                         | Hard       | (double) bfs                                                | :eyes: :v:          |
 | Word Break                                             | Medium     | dp(fast)/recursion(timeout)                                 |                     |
 | Word Search                                            | Medium     | dfs                                                         | :v: :eyes:          |
 | Implement Trie (Prefix Tree)                           | Medium     |                                                             |                     |
 | Add and Search Word â€“ Data structure design            | Medium     |                                                             |                     |
 | Sum of Left Leaves                                     | Easy       | recursion/iterative                                         | :v: :eyes:          |
 | Validate Binary Search Tree                            | Medium     | track min/max for eachsubtree, beter than inorder traversal | :eyes:  :v:         |
 | Binary Tree Level Order Traversal                      | Easy       |                                                             |                     |
 | Populating Next Right Pointers in Each Node            | Medium     |                                                             |                     |
 | Populating Next Right Pointers in Each Node II         | Hard       |                                                             |                     |
 | LRU Cache                                              | Hard       |                                                             |                     |
 | One Edit Distance                                      | Medium     | 3 cases, and combine for concise code                       | :v:                 |
 | Edit Distance                                          | Hard       | 2-dim dp                                                    | :v:  :eyes:         |
 | Excel Sheet Column Title                               | Easy       | mod/division                                                | :v:                 |
 | Number of Islands                                      | Medium     | dfs/marking                                                 | :v:                 |
 | Number of Islands II                                   | Medium     | union find + pass compression                               | :lock: :eyes:       |
 | The Skyline Problem                                    | Hard       | start/end points/mulitset erase                             | :eyes: :v:          |
 | Maximal Square                                         | Medium     | dp/find len of sides                                        | :eyes: :v:          |
 | Maximal Rectangle                                      | Hard       | find width(histogram)/height                                | :eyes: :v:          |
 | Largest Rectangle in Histogram                         | Hard       | stack idea important                                        | :eyes: :v:          |
 | Reverse Linked List                                    | Easy       |                                                             | :v:                 |
 | Valid Palindrome                                       | Easy       |                                                             |                     |
 | Palindrome Linked List                                 | Easy       | stack/reverselist/two pointer                               | :v: :eyes:          |
 | Palindrome Permutation                                 | Easy       |                                                             |                     |
 | Palindromic Substrings                                 | Medium     | dp, str end to front, double-sided expansion faster         | :eyes: :v:          |
 | Longest Palindromic Sub sequence                       | Medium     | dp, back to front, find how to transfer states              | :eyes: :v:          |
 | Longest Palindromic Sub string                         | Medium     | dp, but double-sided expansion is faster                    | :eyes: :v:          |
 | Shortest Palindrome                                    | Hard       |                                                             |                     |
 | Palindrome Pairs                                       | Hard       |                                                             |                     |
 | Lowest Common Ancestor of a Binary Tree                | Medium     | recursion                                                   | :v: :eyes:          |
 | Lowest Common Ancestor of a Binary Search Tree         | Easy       | use bst property                                            | :v:                 |
 | Meeting Rooms                                          | Easy       | easy/customized sorting lambda                              | :v:                 |
 | Meeting Rooms II                                       | Medium     | 1. greedy ideas using pq; 2. sweep line with two arrays     | :eyes: :v:          |
 | Maximum Length of Pair Chains                          | Medium     | sort by ending time then greedy                             | :eyes: :v:          |
 | Course Schedule I                                      | Medium     | dfs/bfs(tricker, use degree)                                | :v:                 |
 | Course Schedule II                                     | Medium     | dfs/bfs(tricker), path tracking                             | :v: :eyes:          |
 | Course Schedule III                                    | Medium     | greedy/replace the course taking longest time               | :eyes:  :v:         |
 | Minimu Height Trees                                    | Medium     | bf timeout, use graph degree                                | :eyes: :v:          |
 | Alien Dictionary                                       | Hard       | order is DAG edges (topological sort)                       | :lock: :eyes:       |
 | Diameter of Binary Tree                                | Medium     | what is needed to compute the path                          | :v:                 |
 | Paint House II                                         | Hard       | dp->no dp storage needed                                    | :lock: :eyes:       |
 | H-Index                                                | Medium     |                                                             |                     |
 | H-Index II                                             | Medium     |                                                             |                     |
 | Find the Celebrity                                     | Medium     | a knows b, a is not candidate; otherwise a is candidate     | :eyes::lock:        |
 | First Bad Version                                      | Easy       |                                                             |                     |
 | Walls and Gates                                        | Medium     | start from gates see how far it goes                        | :v:                 |
 | Inorder Successor in BST                               | Medium     | BST property, track last larger node                        | :eyes: :lock:       |
 | Binary Tree Vertical Order Traversal                   | Medium     | map/inorder recursion/queue iteration                       | :eyes: :lock:       |
 | Increasing Triplet Subsequence                         | Medium     | think hard, tricky                                          | :v: :eyes:          |
 | Random Pick Index                                      | Medium     | reservoir sampling                                          | :eyes: :v:          |
 | Design Tic Tac Toe                                     | Medium     | extra space to keep track of current status                 | :eyes: :lock:       |
 | Restore IP Address                                     | Medium     | recursion                                                   | :eyes: :v:          |
 | Intersection of Two Arrays I/II                        | Easy       | check follow up questions                                   | :eyes: :v:          |

## Other Leetcode
 | Problems                                    | Difficulty | Techniques                                              | Status        |
 | :-------------------------                  | :---:      | :----                                                   | :---:         |
 | Delete a Node in BST                        | Medium     | analyze 3 situations                                    | :eyes: :v:    |
 | Print Binary Tree                           | Medium     | find matrix size, then populate                         | :eyes: :v:    |
 | Find Mode in BST                            | Medium     | BST inorder is sorted                                   | :eyes: :v:    |
 | Add One Row to Tree                         | Medium     | recursion/iterative                                     | :v:           |
 | Find Bottom Left Tree Value                 | Medium     | inorder travesal                                        | :v:           |
 | Most Frequent Subtree Sum                   | Medium     | postorder travesal to capture subtree sum               | :v:           |
 | Count Univalue Subtree                      | Medium     | postorder                                               | :eyes: :lock: |
 | Binary Tree Tilt                            | Easy       | postorder sum and track                                 | :v:           |
 | Merge Two Binary Trees                      | Easy       | recursion                                               | :v:           |
 | Subtree of Another Tree                     | Easy       |                                                         | :v:           |
 | Convert BST to Greater Tree                 | Easy       | right-inorder-left traversal                            | :v:           |
 | Average of Levels in Binary Tree            | Easy       | level order (bfs with queue/dfs)                        | :v:           |
 | Larget Value in Each Tree Row               | Easy       | level order (bfs with queue/dfs)                        | :v:           |
 | Construct String From Binary Tree           | Easy       |                                                         | :v:           |
 | Binary Tree Upside Down                     | Medium     | think about recursive/iterative solution                | :eyes: :v:    |
 | Non-overlapping Intervals                   | Medium     | idea (which one to remove!)                             | :eyes: :v:    |
 | Find Right Interval                         | Medium     | lower bound function                                    | :v:           |
 | Data Stream as Disjoint Intervals           | Hard       | vector vs bst using set, how to merge/insert            | :eyes: :v:    |
 | Range Module                                | Hard       | treemap based/vector based/so many corner case          | :eyes: :v:    |
 | K Inverse Pair Array                        | Hard       | dp formula                                              | :eyes: :v:    |
 | Single Element in Sorted Array              | Medium     | O(lgn) binary search, but how                           | :eyes: :v:    |
 | Number of Boomerangs                        | Easy       | brute force                                             | :v:           |
 | Numbers Disappeared in Array                | Easy       | no extra space, use array itself                        | :v:           |
 | First Missing Positive                      | Hard       | use array itself and index to store value               | :v:           |
 | Next Greater Element I                      | Easy       | O(n) with stack                                         | :eyes: :v:    |
 | Next Greater Element II                     | Medium     | cycular array + stack                                   | :eyes: :v:    |
 | Next Greater Element III                    | Medium     | digits comp, think!!                                    | :eyes: :v:    |
 | Longest Word in Dictionary through Deleting | Medium     |                                                         | :v:           |
 | Relative Ranks                              | Easy       | customized sorting                                      | :v:           |
 | Detect Capitals                             | Easy       |                                                         | :v:           |
 | Shortest Unsorted Continuous Subarray       | Easy       | find the disordered index boundary                      | :eyes: :v:    |
 | Maximum Swap                                | Medium     | locate max after non-decreasing seq                     | :eyes: :v:    |
 | Flatten Binary Tree                         | Medium     | recursion, think about iterative                        | :eyes: :v:    |
 | Max Width of Binary Tree                    | Medium     | BFS with queue (which stores node and index)            | :eyes: :v:    |
 | Majority Element                            | Easy       | cancel out                                              | :v:           |
 | Majority Element II                         | Medium     | extend to n/k case                                      | :eyes: :v:    |
 | Permuation in String                        | Medium     | ideas same as sliding window                            | :v:           |
 | Smallest Range                              | Medium     | same ideas as minimum window string                     | :eyes: :v:    |
 | Maximal Gap                                 | Medium     | bucket sort idea, find bucket size and number of bucket | :eyes: :v:    |
 | Exclusive Time of Functions                 | Medium     | stack                                                   | :eyes: :v:    |
 | Elimination Game                            | Medium     |                                                         | :eyes: :v:    |
 | Top K Frequent Words                        | Medium     | think about how to define comparator                    | :v:           |
 | Top K Frequent Element                      | Medium     | 1. map+heap 2. bucket sort                              | :eyes: :v:    |
 | Equal Tree Partition                        | Medium     | node sum + corner case                                  | :eyes: :v:    |
 | Partition List                              | Medium     | two pointers                                            | :v:           |
 | Palindrom Partition                         | Medium     |                                                         | :eyes: :v:    |
 | Palindrom Partition II                      | Hard       | 1. dp 2. two-sided extending                            | :eyes: :v:    |
 | Balanced Binary Tree                        | Easy       | 1. top-down 2. buttom up                                | :eyes: :v:    |
 | Surrounded Region                           | Medium     | from edge to dfs mark reachable cell                    | :eyes: :v:    |
 | Minimum Path Sum                            | Medium     | 2d dp with 1d store, initial value!                     | :eyes: :v:    |
 | Longest Line of Consecutive Ones in Matrix  | Medium     | 3-dim dp/dfs                                            | :lock:        |

## Linked Lists

 | Problems                   | Difficulty | Techniques                |
 | :------------------------- | :---:      | :----                     |
 | Reverse Linked List        | Easy       | 1. iterative 2. recursive |


## Tree Basics
 | Problems                                    | Difficulty | Techniques                                         |
 | :-------------------------                  | :---:      | :----                                              |
 | Binary Tree PreOrder Travesal/Iterator      | Medium     | iterative/recursive                                |
 | Binary Tree InOrder Travesal/Iterator       | Medium     | iterative/recursive                                |
 | Binary Tree PostOrder Travesal/Iterator     | Hard       | iterative/recursive                                |
 | Binary Tree Serialization/Deserialization   | Medium     | preorder-recursion/level-order iteration           |
 | BST Serialization/Deserialization (compact) | Medium     | preorder-recursion with min/max threshold          |
 | Find Duplicate Subtrees                     | Medium     | serialize to deduplicate, make sure serialize once |
 | Find Leaves of Binary Tree                  | Medium     | bottom up to count the height                      |
 | Binary Tree Maximum Path Sum                | Hard       | how to calculate a path sum                        |
 | Path Sum I/II/III                           | Medium     | III needs more attention                           |
 | Sum of Root to Leave Number                 | Medium     | each deeper level, x10                             |
 | Binary Tree Paths                           | Easy       | dfs                                                |
 | Maximum Binary Tree                         | Medium     | recursion/iterative (think this)                   |
 | Convert Sorted Array/List to BST            | Medium     | concise coding                                     |
 | Convert BST to Double Linked List           | Medium     | think about the recursion                          |
 | Closest Binary Search Tree Value            | Easy       | BST                                                |
 | Closest Binary Search Tree Value II         | Hard       | heap/BST                                           |
 | Binary Tree Longest Consecutive Sequence    | Medium     | top-down to count, and track max length            |
 | Binary Tree Longest Consecutive Sequence II | Medium     | bottom-up to count left/right max inc/dec length   |

## Graph
 | Problems                   | Difficulty | Techniques            |
 | :------------------------- | :---:      | :----                 |
 | Clone Graph                | Medium     | dfs/bfs (avoid cycle) |
 | Graph Valid Tree           | Medium     | dfs/bfs/union find    |

## Classic Backtracing

### common points
- code skeletons for backtracing
```cpp
// recursively call dfs twice w/o current element
// but deduplication is a bit tricker
void dfs(nums, id, path, res){
    // do not include
    dfs(nums, id+1, path, res);
    // do include
    path.push_back(nums[id]);
    dfs(nums, id+1, path, res);
    path.pop_back();
}
// better loop skeleton to add deduplication
// current loop include the element
// next loop pop back to backtrace previous state where the element is not included
// next loop
void dfs(nums, id, path, res) {
    for(int i = id; i < nums.size(); ++i) {
        path.push_back(nums[i]);
        dfs(nums, i+1, path, res);
        path.pop_back();
    }
}

// deduplicate
void dfs(nums, id, path, res) {
    for(int i = id; i < nums.size(); ++i) {
        // obviouse, in the following case, the element is included in the previous stack frame
        if(i > id && nums[i] == nums[i-1]) continue;
        path.push_back(nums[i]);
        dfs(nums, i+1, path, res);
        path.pop_back();
    }
}
```


 | Problems                          | Difficulty | Techniques                                               |
 | :-------------------------        | :---:      | :----                                                    |
 | Subsets                           | Medium     | recursion -> think about iterative                       |
 | Subsets II                        | Medium     | recursion/deduplication                                  |
 | Permutation                       | Medium     | 1) dfs (different from subset) 2) swap recursion         |
 | Permutation II (with duplication) | Medium     | 1) dfs (with de-deuplication) 2) swap with deduplication |
 | Next Permutation                  | Medium     | reverse order check                                      |
 | Combination Sum I/II/III          | Medium     | dfs+backtracing                                          |
 | Combination Sum IV                | Medium     | dp (different from I/II/III)                             |
 | Partition Equal Subset Sum        | Medium     | recursion timout, dp to the rescue                       |
 | Partition to k Equal Sum Subset   | Medium     | dfs recursion                                            |


## Dynamic Programming/Greedy
 | Problems                                             | Difficulty | Techniques                                        |
 | :-------------------------                           | :---:      | :----                                             |
 | Triangle                                             | Medium     | bottom up dp                                      |
 | Decode Ways                                          | Medium     | recursion(slow)/dp(cornor cases)                  |
 | Decode Ways II                                       | Medium     | with * decoded as 1-9                             |
 | Best Time to Buy and Sell Stock I/II                 | Easy       | greedy                                            |  |
 | Best Time to Buy and Sell Stock III/IV               | Hard       | local/global dp, sooo hard                        |  |
 | Best Time to Buy and Sell Stock with Cooldown        | Medium     |                                                   |  |
 | Best Time to Buy and Sell Stock with Transaction Fee | Medium     | current state depends on previous state sell/hold |  |

## String
 | Problems                                               | Difficulty | Techniques                                       |
 | :-------------------------                             | :---:      | :----                                            |
 | Valid Anagrams                                         | Easy       | sort/map                                         |
 | Group Anagrams                                         | Medium     | hash map/sort string                             |
 | Find All Anagrams in String                            | Easy       | sliding window template + map to track count     |
 | Minimum Window Substring                               | Hard       | sliding window template + map/count to track     |
 | Longest subsring without repeating chars               | Medium     | sliding window template + map to index           |
 | Longest Substring with At Most K Distinct Characters   | Hard       | sliding window template + map to rightmost index |
 | Generate Parentheses                                   | Medium     | n-1 -> n                                         |
 | Valid Parentheses                                      | Easy       | stack/non-stack counter solution                 |
 | Remove Invalid Parentheses                             | Hard       | count num to remove, then dfs                    |
 | Remove Invalid Parentheses (return one valid solution) | Hard       | 1.two loops 2. one loop                          |


## Array
 | Problems                            | Difficulty | Techniques                                                      |
 | :-------------------------          | :---:      | :----                                                           |
 | Sparse Vector Multiplication        | Medium     | pair store, 1. two pointer 2. binary search 3. divide & conqure |
 | Sparse Matrix Multiplication        | Medium     | avoid multiplication when possible                              |
 | Rotate Array                        | Easy       | think at lease 3 ways                                           |
 | Search in Rotated Sorted Array      | Medium     | decide which part is sorted, then choose direction              |
 | Search in Rotated Sorted Array II   | Medium     | only start/end equal affects it, how to break this              |
 | Find Min in Rotated Sorted Array    | Medium     | early stop if sorted                                            |
 | Find Min in Rotated Sorted Array II | Medium     | how to break start/mid/end are equal                            |
 | Sort Colors                         | Medium     | two pointer/two side to middle                                  |
 | Contiguous Array                    | Medium     | hash map/presum idea/store mod                                  |
 | Two Sum                             | Easy       | hashmap/two pointer                                             |
 | Two Sum II â€“ Input array is sorted  | Easy       | two pointer to squeeze                                          |
 | Two Sum III â€“ Data structure design | Easy       | hashmap/multiset                                                |
 | Two Sum in BST                      | Easy       | inorder to form sorted array, two pointer                       |
 | 3Sum                                | Medium     | two pointer/de-duplicate                                        |
 | 3Sum Closest                        | Medium     | two pointer/de-dupicate                                         |
 | 3Sum Smaller                        | Medium     | two pointer                                                     |
 | Target Sum                          | Medium     | recursion                                                       |
 | Longest Consecutive Sequence        | Hard       | think differently  (linear solution)                            |


## Bits Manipulation
 | Problems                   | Difficulty | Techniques               |
 | :------------------------- | :---:      | :----                    |
 | Hamming Distance           | Easy       | clear right most left 1  |
 | Total Hamming Distance     | Medium     | vertical 1s, combination |


